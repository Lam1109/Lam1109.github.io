---
date: 2020-07-22 12:27:40
layout: post
title: Spring
subtitle: Spring
description: Spring Framework.
image: /assets/img/post_img/spring.png
optimized_image: /assets/img/post_img/spring.png
category: Java
tags:
  - spring
  - java
author: Lam
paginate: true
---


* [第1章 Spring是什么](#%E7%AC%AC1%E7%AB%A0-spring%E6%98%AF%E4%BB%80%E4%B9%88)
  * [1\.1 概念](#11-%E6%A6%82%E5%BF%B5)
  * [1\.2 优点](#12-%E4%BC%98%E7%82%B9)
    * [1\.2\.1 方便解耦，简化开发](#121-%E6%96%B9%E4%BE%BF%E8%A7%A3%E8%80%A6%E7%AE%80%E5%8C%96%E5%BC%80%E5%8F%91)
    * [1\.2\.2 方便集成各种优秀框架](#122-%E6%96%B9%E4%BE%BF%E9%9B%86%E6%88%90%E5%90%84%E7%A7%8D%E4%BC%98%E7%A7%80%E6%A1%86%E6%9E%B6)
    * [1\.2\.3 降低 Java EE API 的使用难度](#123-%E9%99%8D%E4%BD%8E-java-ee-api-%E7%9A%84%E4%BD%BF%E7%94%A8%E9%9A%BE%E5%BA%A6)
    * [1\.2\.4 方便程序的测试](#124-%E6%96%B9%E4%BE%BF%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%B5%8B%E8%AF%95)
    * [1\.2\.5 AOP 编程的支持](#125-aop-%E7%BC%96%E7%A8%8B%E7%9A%84%E6%94%AF%E6%8C%81)
    * [1\.2\.6 声明式事务的支持](#126-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%94%AF%E6%8C%81)
* [第2章 Spring体系结构](#%E7%AC%AC2%E7%AB%A0-spring%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84)
  * [2\.1 Spring的体系结构](#21-spring%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84)
    * [2\.1\.1 Data Access/Integration（数据访问/集成）](#211-data-accessintegration%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E9%9B%86%E6%88%90)
    * [2\.1\.2 Web模块](#212-web%E6%A8%A1%E5%9D%97)
    * [2\.1\.3 Core Container（核心容器）](#213-core-container%E6%A0%B8%E5%BF%83%E5%AE%B9%E5%99%A8)
    * [2\.1\.4 其他模块](#214-%E5%85%B6%E4%BB%96%E6%A8%A1%E5%9D%97)
* [第3章 Spring的目录结构和JAR包介绍](#%E7%AC%AC3%E7%AB%A0-spring%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%92%8Cjar%E5%8C%85%E4%BB%8B%E7%BB%8D)
  * [3\.1 JAR包介绍与下载](#31-jar%E5%8C%85%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%B8%8B%E8%BD%BD)
    * [3\.1\.1 JAR包介绍](#311-jar%E5%8C%85%E4%BB%8B%E7%BB%8D)
    * [3\.1\.2 JAR包下载](#312-jar%E5%8C%85%E4%B8%8B%E8%BD%BD)
* [第4章 Spring IoC容器](#%E7%AC%AC4%E7%AB%A0-spring-ioc%E5%AE%B9%E5%99%A8)
  * [4\.1 BeanFactory](#41-beanfactory)
  * [4\.2 ApplicationContext](#42-applicationcontext)
    * [4\.2\.1 ClassPathXmlApplicationContext](#421-classpathxmlapplicationcontext)
    * [4\.2\.2 FileSystemXmlApplicationContext](#422-filesystemxmlapplicationcontext)
* [第5章 第一个Spring程序](#%E7%AC%AC5%E7%AB%A0-%E7%AC%AC%E4%B8%80%E4%B8%AAspring%E7%A8%8B%E5%BA%8F)
  * [5\.1 详细步骤](#51-%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4)
    * [5\.1\.1 创建项目](#511-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE)
    * [5\.1\.2 创建 PersonDao 接口](#512-%E5%88%9B%E5%BB%BA-persondao-%E6%8E%A5%E5%8F%A3)
    * [5\.1\.3 创建接口实现类 PersonDaoImpl](#513-%E5%88%9B%E5%BB%BA%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB-persondaoimpl)
    * [5\.1\.4 创建 Spring 配置文件](#514-%E5%88%9B%E5%BB%BA-spring-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6)
    * [5\.1\.5 编写测试类](#515-%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95%E7%B1%BB)
    * [5\.1\.6 运行项目并查看结果](#516-%E8%BF%90%E8%A1%8C%E9%A1%B9%E7%9B%AE%E5%B9%B6%E6%9F%A5%E7%9C%8B%E7%BB%93%E6%9E%9C)
* [第6章 Spring DI（依赖注入）](#%E7%AC%AC6%E7%AB%A0-spring-di%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5)
  * [6\.1 依赖注入的两种实现方式](#61-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F)
    * [6\.1\.1  创建 PersonService 接口](#611--%E5%88%9B%E5%BB%BA-personservice-%E6%8E%A5%E5%8F%A3)
    * [6\.1\.2 创建接口实现类 PersonServiceImpl](#612-%E5%88%9B%E5%BB%BA%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB-personserviceimpl)
    * [6\.1\.3 在 applicationContext\.xml 中添加配置信息](#613-%E5%9C%A8-applicationcontextxml-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF)
    * [6\.1\.4 编写测试方法](#614-%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95)
    * [6\.1\.5 运行项目并查看结果](#615-%E8%BF%90%E8%A1%8C%E9%A1%B9%E7%9B%AE%E5%B9%B6%E6%9F%A5%E7%9C%8B%E7%BB%93%E6%9E%9C)
* [第7章 Spring Bean](#%E7%AC%AC7%E7%AB%A0-spring-bean)
  * [7\.1 Spring Bean的配置及常用属性](#71-spring-bean%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7)
    * [7\.1\.1 定义 Bean 的示例代码](#711-%E5%AE%9A%E4%B9%89-bean-%E7%9A%84%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81)
    * [7\.1\.2 元素的常用属性](#712-%E5%85%83%E7%B4%A0%E7%9A%84%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7)
  * [7\.2 Spring实例化Bean的三种方法](#72-spring%E5%AE%9E%E4%BE%8B%E5%8C%96bean%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95)
    * [7\.2\.1 构造器实例化](#721-%E6%9E%84%E9%80%A0%E5%99%A8%E5%AE%9E%E4%BE%8B%E5%8C%96)
      * [7\.2\.1\.1 创建项目并导入 JAR 包](#7211-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%B9%B6%E5%AF%BC%E5%85%A5-jar-%E5%8C%85)
      * [7\.2\.1\.2 创建实体类](#7212-%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BD%93%E7%B1%BB)
      * [7\.2\.1\.3 创建 Spring 配置文件](#7213-%E5%88%9B%E5%BB%BA-spring-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6)
      * [7\.2\.1\.4 创建测试类](#7214-%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E7%B1%BB)
      * [7\.2\.1\.5 运行程序并查看结果](#7215-%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%B9%B6%E6%9F%A5%E7%9C%8B%E7%BB%93%E6%9E%9C)
  * [7\.2\.2 静态工厂方式实例化](#722-%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E5%BC%8F%E5%AE%9E%E4%BE%8B%E5%8C%96)
      * [7\.2\.2\.1 创建实体类](#7221-%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BD%93%E7%B1%BB)
      * [7\.2\.2\.2 创建静态工厂类](#7222-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E7%B1%BB)
      * [7\.2\.2\.3 创建 Spring 配置文件](#7223-%E5%88%9B%E5%BB%BA-spring-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6)
      * [7\.2\.2\.4 创建测试类](#7224-%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E7%B1%BB)
      * [7\.2\.2\.5 运行程序并查看结果](#7225-%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%B9%B6%E6%9F%A5%E7%9C%8B%E7%BB%93%E6%9E%9C)
  * [7\.2\.3 实例工厂方式实例化](#723-%E5%AE%9E%E4%BE%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E5%BC%8F%E5%AE%9E%E4%BE%8B%E5%8C%96)
      * [7\.2\.3\.1 创建实体类](#7231-%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BD%93%E7%B1%BB)
      * [7\.2\.3\.2 创建实例工厂类](#7232-%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B%E5%B7%A5%E5%8E%82%E7%B1%BB)
      * [7\.2\.3\.3 创建 Spring 配置文件](#7233-%E5%88%9B%E5%BB%BA-spring-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6)
      * [7\.2\.3\.4 创建测试类](#7234-%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E7%B1%BB)
      * [7\.2\.3\.5 运行程序并查看结果](#7235-%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%B9%B6%E6%9F%A5%E7%9C%8B%E7%BB%93%E6%9E%9C)
  * [7\.3 Spring中Bean的作用域](#73-spring%E4%B8%ADbean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F)
    * [7\.3\.1 singleton 作用域](#731-singleton-%E4%BD%9C%E7%94%A8%E5%9F%9F)
      * [7\.3\.1\.1 创建类](#7311-%E5%88%9B%E5%BB%BA%E7%B1%BB)
      * [7\.3\.1\.2 创建配置文件](#7312-%E5%88%9B%E5%BB%BA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6)
      * [7\.3\.1\.3 创建测试类](#7313-%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E7%B1%BB)
      * [7\.3\.1\.4 运行程序并查看结果](#7314-%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%B9%B6%E6%9F%A5%E7%9C%8B%E7%BB%93%E6%9E%9C)
    * [7\.3\.2 prototype 作用域](#732-prototype-%E4%BD%9C%E7%94%A8%E5%9F%9F)
      * [7\.3\.2\.1 修改配置文件](#7321-%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6)
      * [7\.3\.2\.2 运行程序并查看结果](#7322-%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%B9%B6%E6%9F%A5%E7%9C%8B%E7%BB%93%E6%9E%9C)
  * [7\.4 Spring Bean的生命周期](#74-spring-bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F)
  * [7\.5 Bean 的装配方式](#75-bean-%E7%9A%84%E8%A3%85%E9%85%8D%E6%96%B9%E5%BC%8F)
    * [7\.5\.1 Spring基于XML装配Bean](#751-spring%E5%9F%BA%E4%BA%8Exml%E8%A3%85%E9%85%8Dbean)
      * [7\.5\.1\.1 创建 Person 类](#7511-%E5%88%9B%E5%BB%BA-person-%E7%B1%BB)
      * [7\.5\.1\.2 创建 Spring 配置文件](#7512-%E5%88%9B%E5%BB%BA-spring-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6)
      * [7\.5\.1\.3 创建测试类](#7513-%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E7%B1%BB)
      * [7\.5\.1\.4 运行项目并查看结果](#7514-%E8%BF%90%E8%A1%8C%E9%A1%B9%E7%9B%AE%E5%B9%B6%E6%9F%A5%E7%9C%8B%E7%BB%93%E6%9E%9C)
    * [7\.5\.2 Spring基于Annotation装配Bean](#752-spring%E5%9F%BA%E4%BA%8Eannotation%E8%A3%85%E9%85%8Dbean)
      * [7\.5\.2\.1 创建 DAO 层接口](#7521-%E5%88%9B%E5%BB%BA-dao-%E5%B1%82%E6%8E%A5%E5%8F%A3)
      * [7\.5\.2\.2 创建 DAO 层接口的实现类](#7522-%E5%88%9B%E5%BB%BA-dao-%E5%B1%82%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB)
      * [7\.5\.2\.3 创建 Service 层接口](#7523-%E5%88%9B%E5%BB%BA-service-%E5%B1%82%E6%8E%A5%E5%8F%A3)
      * [7\.5\.2\.4 创建 Service 层接口的实现类](#7524-%E5%88%9B%E5%BB%BA-service-%E5%B1%82%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB)
      * [7\.5\.2\.5 创建 Action](#7525-%E5%88%9B%E5%BB%BA-action)
      * [7\.5\.2\.6 创建 Spring 配置文件](#7526-%E5%88%9B%E5%BB%BA-spring-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6)
      * [7\.5\.2\.7 创建测试类](#7527-%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E7%B1%BB)
      * [7\.5\.2\.8 运行程序并查看结果](#7528-%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%B9%B6%E6%9F%A5%E7%9C%8B%E7%BB%93%E6%9E%9C)
    * [7\.5\.3 Spring自动装配Bean](#753-spring%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8Dbean)
      * [7\.5\.3\.1 创建包](#7531-%E5%88%9B%E5%BB%BA%E5%8C%85)
      * [7\.5\.3\.2 修改PersonAction类和PersonServiceImpl类](#7532-%E4%BF%AE%E6%94%B9personaction%E7%B1%BB%E5%92%8Cpersonserviceimpl%E7%B1%BB)
      * [7\.5\.3\.3 修改 Spring 配置文件](#7533-%E4%BF%AE%E6%94%B9-spring-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6)
      * [7\.5\.3\.4 运行程序并查看结果](#7534-%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%B9%B6%E6%9F%A5%E7%9C%8B%E7%BB%93%E6%9E%9C)
* [第8章 Spring AOP](#%E7%AC%AC8%E7%AB%A0-spring-aop)
  * [8\.1 AOP的概念](#81-aop%E7%9A%84%E6%A6%82%E5%BF%B5)
  * [8\.2 Spring JDK动态代理](#82-spring-jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86)
    * [8\.2\.1 JDK 动态代理的示例](#821-jdk-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E7%A4%BA%E4%BE%8B)
      * [8\.2\.1\.1 创建项目](#8211-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE)
      * [8\.2\.1\.2 创建接口 CustomerDao](#8212-%E5%88%9B%E5%BB%BA%E6%8E%A5%E5%8F%A3-customerdao)
      * [8\.2\.1\.3 创建实现类 CustomerDaoImpl](#8213-%E5%88%9B%E5%BB%BA%E5%AE%9E%E7%8E%B0%E7%B1%BB-customerdaoimpl)
      * [8\.2\.1\.4 创建切面类 MyAspect](#8214-%E5%88%9B%E5%BB%BA%E5%88%87%E9%9D%A2%E7%B1%BB-myaspect)
      * [8\.2\.1\.5 创建代理类 MyBeanFactory](#8215-%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E7%B1%BB-mybeanfactory)
      * [8\.2\.1\.6 创建测试类 JDKProxyTest](#8216-%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E7%B1%BB-jdkproxytest)
      * [8\.2\.1\.7 运行项目并查看结果](#8217-%E8%BF%90%E8%A1%8C%E9%A1%B9%E7%9B%AE%E5%B9%B6%E6%9F%A5%E7%9C%8B%E7%BB%93%E6%9E%9C)
  * [8\.3 Spring CGLIB动态代理](#83-spring-cglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86)
    * [8\.3\.1 CGLIB 动态代理的示例](#831-cglib-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E7%A4%BA%E4%BE%8B)
      * [8\.3\.1\.1 创建目标类 GoodsDao](#8311-%E5%88%9B%E5%BB%BA%E7%9B%AE%E6%A0%87%E7%B1%BB-goodsdao)
      * [8\.3\.1\.2 创建代理类 MyBeanFactory](#8312-%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E7%B1%BB-mybeanfactory)
      * [8\.3\.1\.3 创建测试类](#8313-%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E7%B1%BB)
      * [8\.3\.1\.4 运行项目并查看结果](#8314-%E8%BF%90%E8%A1%8C%E9%A1%B9%E7%9B%AE%E5%B9%B6%E6%9F%A5%E7%9C%8B%E7%BB%93%E6%9E%9C)
  * [8\.4 Spring 通知类型及创建AOP代理](#84-spring-%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%88%9B%E5%BB%BAaop%E4%BB%A3%E7%90%86)
    * [8\.4\.1 Spring 通知类型](#841-spring-%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B)
    * [8\.4\.2 声明式 Spring AOP](#842-%E5%A3%B0%E6%98%8E%E5%BC%8F-spring-aop)
      * [8\.4\.2\.1 创建切面类 MyAspect](#8421-%E5%88%9B%E5%BB%BA%E5%88%87%E9%9D%A2%E7%B1%BB-myaspect)
      * [8\.4\.2\.2 创建 Spring 配置文件](#8422-%E5%88%9B%E5%BB%BA-spring-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6)
      * [8\.4\.2\.3 创建测试类](#8423-%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E7%B1%BB)
      * [8\.4\.2\.4 运行项目并查看结果](#8424-%E8%BF%90%E8%A1%8C%E9%A1%B9%E7%9B%AE%E5%B9%B6%E6%9F%A5%E7%9C%8B%E7%BB%93%E6%9E%9C)
  * [8\.5 使用AspectJ开发AOP](#85-%E4%BD%BF%E7%94%A8aspectj%E5%BC%80%E5%8F%91aop)
    * [8\.5\.1 基于XML的声明式](#851-%E5%9F%BA%E4%BA%8Exml%E7%9A%84%E5%A3%B0%E6%98%8E%E5%BC%8F)
      * [8\.5\.1\.1 创建切面类 MyAspect](#8511-%E5%88%9B%E5%BB%BA%E5%88%87%E9%9D%A2%E7%B1%BB-myaspect)
      * [8\.5\.1\.2 创建 Spring 配置文件](#8512-%E5%88%9B%E5%BB%BA-spring-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6)
      * [8\.5\.1\.3 创建测试类](#8513-%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E7%B1%BB)
      * [8\.5\.1\.4  运行项目并查看结果](#8514--%E8%BF%90%E8%A1%8C%E9%A1%B9%E7%9B%AE%E5%B9%B6%E6%9F%A5%E7%9C%8B%E7%BB%93%E6%9E%9C)
    * [8\.5\.2 基于 Annotation 的声明式](#852-%E5%9F%BA%E4%BA%8E-annotation-%E7%9A%84%E5%A3%B0%E6%98%8E%E5%BC%8F)
      * [8\.5\.2\.1 创建切面类 MyAspect](#8521-%E5%88%9B%E5%BB%BA%E5%88%87%E9%9D%A2%E7%B1%BB-myaspect)
      * [8\.5\.2\.2 为目标类添加注解](#8522-%E4%B8%BA%E7%9B%AE%E6%A0%87%E7%B1%BB%E6%B7%BB%E5%8A%A0%E6%B3%A8%E8%A7%A3)
      * [8\.5\.2\.3 创建Spring配置文件](#8523-%E5%88%9B%E5%BB%BAspring%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6)
      * [8\.5\.2\.4 创建测试类](#8524-%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E7%B1%BB)
      * [8\.5\.2\.5 运行项目并查看结果](#8525-%E8%BF%90%E8%A1%8C%E9%A1%B9%E7%9B%AE%E5%B9%B6%E6%9F%A5%E7%9C%8B%E7%BB%93%E6%9E%9C)
* [第9章 Spring JDBC 与事务管理](#%E7%AC%AC9%E7%AB%A0-spring-jdbc-%E4%B8%8E%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86)
  * [9\.1 Spring JDBC](#91-spring-jdbc)
  * [9\.2 事务管理](#92-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86)
    * [9\.2\.1 基于 XML 方式的事务管理](#921-%E5%9F%BA%E4%BA%8E-xml-%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86)
      * [9\.2\.1\.1 创建项目](#9211-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE)
      * [9\.2\.1\.2 创建数据库、表以及插入数据](#9212-%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E4%BB%A5%E5%8F%8A%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE)
      * [9\.2\.1\.3 创建 c3p0\-db\.properties](#9213-%E5%88%9B%E5%BB%BA-c3p0-dbproperties)
      * [9\.2\.1\.4 实现 DAO](#9214-%E5%AE%9E%E7%8E%B0-dao)
        * [9\.2\.1\.4\.1 创建 AccountDao 接口](#92141-%E5%88%9B%E5%BB%BA-accountdao-%E6%8E%A5%E5%8F%A3)
        * [9\.2\.1\.4\.2 创建 DAO 层接口实现类](#92142-%E5%88%9B%E5%BB%BA-dao-%E5%B1%82%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB)
      * [9\.2\.1\.5 实现 Service](#9215-%E5%AE%9E%E7%8E%B0-service)
        * [9\.2\.1\.5\.1 创建 Service 层接口](#92151-%E5%88%9B%E5%BB%BA-service-%E5%B1%82%E6%8E%A5%E5%8F%A3)
        * [9\.2\.1\.5\.2 创建 Service 层接口实现类](#92152-%E5%88%9B%E5%BB%BA-service-%E5%B1%82%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB)
      * [9\.2\.1\.6 创建 Spring 配置文件](#9216-%E5%88%9B%E5%BB%BA-spring-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6)
      * [9\.2\.1\.7 创建测试类](#9217-%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E7%B1%BB)
      * [9\.2\.1\.8 运行程序并查看结果](#9218-%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%B9%B6%E6%9F%A5%E7%9C%8B%E7%BB%93%E6%9E%9C)
    * [9\.2\.2 基于 Annotation 注解的事务管理](#922-%E5%9F%BA%E4%BA%8E-annotation-%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86)
      * [9\.2\.2\.1 注册驱动](#9221-%E6%B3%A8%E5%86%8C%E9%A9%B1%E5%8A%A8)
      * [9\.2\.2\.2 添加 @Transactional 注解](#9222-%E6%B7%BB%E5%8A%A0-transactional-%E6%B3%A8%E8%A7%A3)
      * [9\.2\.2\.3 运行程序并查看结果](#9223-%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%B9%B6%E6%9F%A5%E7%9C%8B%E7%BB%93%E6%9E%9C)

---

# 第1章 Spring是什么

## 1.1 概念
- Spring是分层的JavaSE/EE full-stack 轻量级开源框架，以IoC（Inverse of Control 控制反转）和AOP（Aspect Oriented Programming 面向切面编程）为内核，使用基本的JavaBean来开发Java应用程序。
- 通常服务器端在采用三层体系架构，分别为表示层(Web)、业务逻辑层(Service)、持久层(Dao)， Spring对每一层都提供了技术支持。

## 1.2 优点
### 1.2.1 方便解耦，简化开发
- Spring就是一个大工厂，可以将所有对象的创建和依赖关系的维护交给 Spring 管理。

### 1.2.2 方便集成各种优秀框架
- Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如Struts2、Hibernate、MyBatis 等）的直接支持。

### 1.2.3 降低 Java EE API 的使用难度
- Spring 对 Java EE 开发中非常难用的一些API（JDBC、JavaMail、远程调用等）都提供了封装，使这些 API 应用的难度大大降低。

### 1.2.4 方便程序的测试
- Spring 支持 JUnit4，可以通过注解方便地测试 Spring 程序。

### 1.2.5 AOP 编程的支持
- Spring 提供面向切面编程，可以方便地实现对程序进行权限拦截和运行监控等功能。

### 1.2.6 声明式事务的支持
- 只需要通过配置就可以完成对事务的管理，而无须手动编程。

---

# 第2章 Spring体系结构

## 2.1 Spring的体系结构

![image](/assets/img/post_img/springframework.png)

### 2.1.1 Data Access/Integration（数据访问/集成）
- 数据访问/集成层包括 JDBC、ORM、OXM、JMS 和 Transactions模块，具体介绍如下:

> 1. JDBC 模块：提供了一个JDBC的抽象层，大幅度减少了在开发过程中对数据库操作的编码。
> 2. ORM 模块：对流行的对象关系映射API，包括JPA、JDO、Hibernate和iBatis提供了的集成层。
> 3. OXM 模块：提供了一个支持对象/XML映射的抽象层实现，如JAXB、Castor、XMLBeans、JiBX 和 XStream。
> 4. JMS 模块：指Java消息服务，包含的功能为生产和消费的信息。
> 5. Transactions 事务模块：支持编程和声明式事务管理实现特殊接口类，并为所有的POJO。

### 2.1.2 Web模块
- Spring 的 Web 层包括 Web、Servlet、Struts 和 Portlet 组件，具体介绍如下：

> 1. Web模块：提供了基本的Web开发集成特性，例如多文件上传功能、使用的Servlet监听器的IoC容器初始化以及Web应用上下文。
> 2. Servlet模块：包括Spring模型—视图—控制器（MVC）实现Web应用程序。
> 3. Struts模块：包含支持类内的 Spring 应用程序，集成了经典的Struts Web层。
> 4. Portlet模块：提供了在Portlet环境中使用MVC实现，类似Web-Servlet模块的功能。

### 2.1.3 Core Container（核心容器）
- Spring 的核心容器是其他模块建立的基础，由Beans模块、Core核心模块、Context上下文模块和Expression Language表达式语言模块组成，具体介绍如下：

> 1. Beans模块：提供了BeanFactory，是工厂模式的经典实现，Spring将管理对象称为Bean。
> 2. Core核心模块：提供了Spring 框架的基本组成部分，包括IoC和DI功能。
> 3. Context上下文模块：建立在核心和Beans模块的基础之上，它是访问定义和配置任何对象的媒介。ApplicationContext接口是上下文模块的焦点。
> 4. Expression Language模块：是运行时查询和操作对象图的强大的表达式语言。

### 2.1.4 其他模块
- Spring的其他模块还有 AOP、Aspects、Instrumentation 以及 Test 模块，具体介绍如下：

> 1. AOP模块：提供了面向切面编程实现，允许定义方法拦截器和切入点，将代码按照功能进行分离，以降低耦合性。
> 2. Aspects模块：提供与AspectJ的集成，是一个功能强大且成熟的面向切面编程（AOP）框架。
> 3. Instrumentation 模块：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用。
> 4. Test模块：支持Spring组件，使用JUnit或TestNG框架的测试。

---

# 第3章 Spring的目录结构和JAR包介绍

## 3.1 JAR包介绍与下载

### 3.1.1 JAR包介绍
- 有四个 JAR 文件是Spring框架的基础包，分别对应Spring容器的四个模块。

<table>
  <thead>
    <tr>
      <th>名称</th>
      <th>作用</th>
    </tr>
  </thead>
    <tbody>
    <tr>
      <td>spring-core-3.2.13.RELEASE.jar</td>
      <td>包含 Spring 框架基本的核心工具类，Spring 其他组件都要用到这个包中的类，是其他组件的基本核心。</td>
    </tr>
    <tr>
      <td>spring-beans-3.2.13.RELEASE.jar</td>
      <td>所有应用都要用到的，它包含访问配置文件、创建和管理bean以及进行Inversion of Control（IoC）或者Dependency Injection（DI）操作相关的所有类。</td>
    </tr>
    <tr>
      <td>spring-context-3.2.13.RELEASE.jar</td>
      <td>RSpring 提供在基础IoC功能上的扩展服务，此外还提供许多企业级服务的支持，如邮件服务、任务调度、JNDI定位、EJB集成、远程访问、缓存以及各种视图层框架的封装等。</td>
    </tr>
    <tr>
      <td>spring-expression-3.2.13.RELEASE.jar</td>
      <td>定义了 Spring 的表达式语言。需要注意的是，在使用Spring开发时，除了Spring自带的JAR包以外，还需要一个第三方JAR包commons.logging处理日志信息。</td>
    </tr>
  </tbody>
</table>

### 3.1.2 JAR包下载
- <a href="https://repo.spring.io/simple/libs-release-local/org/springframework/spring/">点击此处</a>下载Spring JAR包。
- <a href="https://commons.apache.org/proper/commons-logging/download_logging.cgi">点击此处</a>下载commons-logging.1.2。

---

# 第4章 Spring IoC容器
- IoC 是指在程序开发中，实例的创建不再由调用者管理，而是由Spring容器创建。Spring容器会负责控制程序之间的关系，而不是由程序代码直接控制，因此，控制权由程序代码转移到了Spring容器中，控制权发生了反转，这就是Spring的IoC思想。
- Spring 提供了两种IoC容器，分别为**BeanFactory**和**ApplicationContext**，接下来将针对这两种IoC容器进行详细讲解。

## 4.1 BeanFactory
- BeanFactory是基础类型的IoC容器，它由org.springframework.beans.facytory.BeanFactory接口定义，并提供了完整的IoC服务支持。简单来说，BeanFactory就是一个管理Bean的工厂，它主要负责初始化各种Bean，并调用它们的生命周期方法。
- BeanFactory接口有多个实现类，最常见的是org.springframework.beans.factory.xml.XmlBeanFactory，它是根据 XML 配置文件中的定义装配Bean的。

```java
/** 创建BeanFactory实例时，
  * 需要提供Spring所管理容器的详细配置信息，
  * 这些信息通常采用 XML 文件形式管理。
  */
BeanFactory beanFactory = new XmlBeanFactory(new FileSystemResource("D://applicationContext.xml"));
```

## 4.2 ApplicationContext
- ApplicationContext是BeanFactory的子接口，也被称为应用上下文。该接口的全路径为org.springframework.context.ApplicationContext，它不仅提供了BeanFactory的所有功能，还添加了对i18n（国际化）、资源访问、事件传播等方面的良好支持。

### 4.2.1 ClassPathXmlApplicationContext

```java
/** 该类从类路径ClassPath中寻找指定的XML配置文件，
  * 找到并装载完成ApplicationContext的实例化工作。
  */
ApplicationContext applicationContext = new ClassPathXmlApplicationContext(String configLocation);
// configLocation参数用于指定Spring配置文件的名称和位置，如applicationContext.xml
```

### 4.2.2 FileSystemXmlApplicationContext

```java
/** 该类从指定的文件系统路径中寻找指定的XML配置文件，
  * 找到并装载完成ApplicationContext的实例化工作。
  */
ApplicationContext applicationContext = new FileSystemXmlApplicationContext(String configLocation);
/** 它与ClassPathXmlApplicationContext的区别是：
  * 在读取 Spring 的配置文件时，
  * FileSystemXmlApplicationContext不再从类路径中读取配置文件，
  * 而是通过参数指定配置文件的位置，
  * 它可以获取类路径之外的资源，
  * 如“F：/workspaces/applicationContext.xml”。
  */
```

---

# 第5章 第一个Spring程序
## 5.1 详细步骤
### 5.1.1 创建项目
- 在IDEA中创建Web项目**springDemo01**，将Spring框架所需的JAR包复制到项目的lib目录中，并将其添加到类路径下。

> spring-core-3.2.13.RELEASE.jar  
  spring-beans-3.2.13.RELEASE.jar  
  spring-context-3.2.13.RELEASE.jar  
  spring-expression-3.2.13.RELEASE.jar  
  commons-logging.1.2

### 5.1.2 创建 PersonDao 接口
- 在项目的src目录下创建一个名为**com.spring.ioc**的包，然后在该包中创建一个名为**PersonDao**的接口，并在接口中添加一个 **add()** 方法，如下所示。

```java
package com.spring.ioc;

public interface PersonDao {
    public void add();
}
```

### 5.1.3 创建接口实现类 PersonDaoImpl
- 在 **com.spring.ioc** 包下创建 **PersonDao** 的实现类 **PersonDaoImpl**，编辑后如下所示。

```java
package com.spring.ioc;

public class PersonDaoImpl implements PersonDao {
    @Override
    public void add() {
        System.out.println("add()执行了...");
    }
}
```

### 5.1.4 创建 Spring 配置文件
- 在 src 目录下创建 Spring 的核心配置文件 **applicationContext.xml**，编辑后如下所示。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.2.xsd">
    <!-- 由 Spring容器创建该类的实例对象 -->
    <bean id="personDao" class="com.spring.ioc.PersonDaoImpl" />
    <bean id="personService" class="com.spring.ioc.PersonServiceImpl">
        <!-- 将personDao实例注入personService实例中 -->
        <property name="personDao" ref="personDao"/>
    </bean>
</beans>
```
- 上述代码中，第 2～5 行代码是 Spring 的约束配置，第 7 行代码表示在 Spring 容器中创建一个 id 为 personDao 的 bean 实例，其中 id 表示文件中的唯一标识符，class 属性表示指定需要实例化 Bean 的实全限定类名（包名+类名）。
- Spring 的配置文件名称是可以自定义的，通常情况下，都会将配置文件命名为 applicationContext.xml。

### 5.1.5 编写测试类
- 在 **com.spring.ioc** 包下创建测试类 **FirstTest**，并在该类中添加一个名为 **test1()** 的方法，编辑后如下所示。

```java
package com.spring.ioc;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class FirstTest {
    @Test
    public void test1() {
        // 定义Spring配置文件的路径
        String xmlPath = "applicationContext.xml";
        // 初始化Spring容器，加载配置文件
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(
                xmlPath);
        // 通过容器获取personDao实例
        PersonDao personDao = (PersonDao) applicationContext
                .getBean("personDao");
        personDao.add();
    }
}
```

### 5.1.6 运行项目并查看结果
> add()执行了...

---

# 第6章 Spring DI（依赖注入）
- 依赖注入（Dependency Injection，DI）和控制反转含义相同，它们是从两个角度描述的同一个概念。
- 当某个 Java 实例需要另一个 Java 实例时，传统的方法是由调用者创建被调用者的实例（例如，使用 new 关键字获得被调用者实例），而使用 Spring 框架后，被调用者的实例不再由调用者创建，而是由 Spring 容器创建，这称为控制反转。
- Spring 容器在创建被调用者的实例时，会自动将调用者需要的对象实例注入给调用者，这样，调用者通过 Spring 容器获得被调用者实例，这称为依赖注入。

## 6.1 依赖注入的两种实现方式

> 1. 属性 setter 注入  
指 IoC 容器使用 setter 方法注入被依赖的实例。通过调用无参构造器或无参 static 工厂方法实例化 bean 后，调用该 bean 的 setter 方法，即可实现基于 setter 的 DI。
> 2. 构造方法注入  
指 IoC 容器使用构造方法注入被依赖的实例。基于构造器的 DI 通过调用带参数的构造方法实现，每个参数代表一个依赖。


### 6.1.1  创建 PersonService 接口
- 在 springDemo01 项目的 **com.spring.ioc** 包下创建一个名为 **PersonService** 的接口，该接口中包含一个 **addPerson()** 方法，如下所示。

```java
package com.spring.ioc;

public interface PersonService {
    public void addPerson();
}
```

### 6.1.2 创建接口实现类 PersonServiceImpl
- 在 **com.spring.ioc** 包下创建一个名为 **PersonServiceImpl** 的类，该类实现了 **PersonService** 接口，如下所示。

```java
package com.spring.ioc;

public class PersonServiceImpl implements PersonService {
    // 定义接口声明
    private PersonDao personDao;
    // 提供set()方法，用于依赖注入
    public void setPersonDao(PersonDao personDao) {
        this.personDao = personDao;
    }
    // 实现PersonService接口的方法
    @Override
    public void addPerson() {
        personDao.add(); // 调用PersonDao中的add()方法
        System.out.println("addPerson()执行了...");
    }
}
```

### 6.1.3 在 applicationContext.xml 中添加配置信息
- 在 applicationContext.xml 配置文件中添加一个 <bean> 元素，用于实例化 PersonServiceImpl 类，并将 personDao 的实例注入到 personService 中，其实现代码如下所示：

```xml
    <bean id="personService" class="com.spring.ioc.PersonServiceImpl">
        <!-- 将personDao实例注入personService实例中 -->
        <property name="personDao" ref="personDao"/>
    </bean>
```

### 6.1.4 编写测试方法
- 在 FirstTest 类中创建一个名为 test2() 的方法，编辑后如下所示：

```java
  @Test
    public void test2() {
        // 定义Spring配置文件的路径
        String xmlPath = "applicationContext.xml";
        // 初始化Spring容器，加载   配置文件
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(
                xmlPath);
        // 通过容器获取personService实例
        PersonService personService = (PersonService) applicationContext
                .getBean("personService");
        // 调用personService的addPerson()方法
        personService.addPerson();
    }
```

### 6.1.5 运行项目并查看结果

> add()执行了...  
addPerson()执行了...

---

# 第7章 Spring Bean

## 7.1 Spring Bean的配置及常用属性
- Spring 容器可以被看作一个大工厂，而 Spring 容器中的 Bean 就相当于该工厂的产品。如果希望这个大工厂能够生产和管理 Bean，这时则需要告诉容器需要哪些 Bean，以及需要以何种方式将这些 Bean 装配到一起。
- Spring 配置文件支持两种不同的格式，分别是 XML 文件格式和 Properties 文件格式。
- 通常情况下，Spring 会以 XML 文件格式作为 Spring 的配置文件，这种配置方式通过 XML 文件注册并管理 Bean 之间的依赖关系。
- XML 格式配置文件的根元素是 **<beans>**，该元素包含了多个 **<bean>** 子元素，每一个 **<bean>** 子元素定义了一个 Bean，并描述了该 Bean 如何被装配到 Spring 容器中。

### 7.1.1 定义 Bean 的示例代码

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.2.xsd">
    <!-- 使用id属性定义person1，其对应的实现类为com.mengma.person1 -->
    <bean id="person1" class="com.mengma.damain.Person1" />
    <!--使用name属性定义person2，其对应的实现类为com.mengma.domain.Person2-->
    <bean name="Person2" class="com.mengma.domain.Person2"/>
</beans>
```

> 在上述代码中，分别使用 id 和 name 属性定义了两个 Bean，并使用 class 元素指定了 Bean 对应的实现类。

### 7.1.2 <bean>元素的常用属性

<table>
  <thead>
    <tr>
      <th>属性名称</th>
      <th>描述</th>
    </tr>
  </thead>
    <tbody>
    <tr>
      <td>id</td>
      <td>是一个 Bean 的唯一标识符，Spring 容器对 Bean 的配置和管理都通过该属性完成</td>
    </tr>
    <tr>
      <td>name</td>
      <td>Spring 容器同样可以通过此属性对容器中的 Bean 进行配置和管理，name 属性中可以为 Bean 指定多个名称，每个名称之间用逗号或分号隔开</td>
    </tr>
    <tr>
      <td>class</td>
      <td>该属性指定了 Bean 的具体实现类，它必须是一个完整的类名，使用类的全限定名</td>
    </tr>
    <tr>
      <td>scope</td>
      <td>用于设定 Bean 实例的作用域，其属性值有 singleton（单例）、prototype（原型）、request、session 和 global Session。其默认值是 singleton</td>
    </tr>
    <tr>
      <td>constructor-arg</td>
      <td> &lt;bean&gt;元素的子元素，可以使用此元素传入构造参数进行实例化。该元素的 index 属性指定构造参数的序号（从 0 开始），type 属性指定构造参数的类型</td>
    </tr>
    <tr>
      <td>property</td>
      <td>&lt;bean&gt;元素的子元素，用于调用 Bean 实例中的 Set 方法完成属性赋值，从而完成依赖注入。该元素的 name 属性指定 Bean 实例中的相应属性名</td>
    </tr>
    <tr>
      <td>ref</td>
      <td>&lt;property&gt; 和 &lt;constructor-arg&gt; 等元素的子元索，该元素中的 bean 属性用于指定对 Bean 工厂中某个 Bean 实例的引用</td>
    </tr>
    <tr>
      <td>value</td>
      <td>&lt;property&gt; 和 &lt;constractor-arg&gt; 等元素的子元素，用于直接指定一个常量值</td>
    </tr>
    <tr>
      <td>list</td>
      <td>用于封装 List 或数组类型的依赖注入</td>
    </tr>
    <tr>
      <td>set</td>
      <td>用于封装 Set 类型属性的依赖注入</td>
    </tr>
    <tr>
      <td>map</td>
      <td>用于封装 Map 类型属性的依赖注入</td>
    </tr>
    <tr>
      <td>entry</td>
      <td>&lt;map&gt;  元素的子元素，用于设置一个键值对。其 key 属性指定字符串类型的键值，ref 或 value 子元素指定其值</td>
    </tr>
  </tbody>
</table>

## 7.2 Spring实例化Bean的三种方法
- 在 Spring 中，实例化 Bean 有三种方式，分别是构造器实例化、静态工厂方式实例化和实例工厂方式实例化。

### 7.2.1 构造器实例化

#### 7.2.1.1 创建项目并导入 JAR 包
- 在 IDEA 中创建一个名称为 **springDemo02** 的 Web 项目，然后将 Spring 支持和依赖的 JAR 包复制到项目的 lib 目录中，并发布到类路径下。

#### 7.2.1.2 创建实体类
- 在项目的 src 目录下创建一个名为 **com.spring.instance.constructor** 的包，在该包下创建一个实体类 **Person1**，如下所示。

```java
package com.spring.instance.constructor;

public class Person1 {
}
```

#### 7.2.1.3 创建 Spring 配置文件
- 在 **com.spring.instance.constructor** 包下创建 Spring 的配置文件 **applicationContext.xml**，编辑后如下所示。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.2.xsd">
    <bean id="person1" class="com.spring.instance.constructor.Person1" />
</beans>
```

#### 7.2.1.4 创建测试类
- 在 **com.spring.instance.constructor** 包下创建一个名为 **InstanceTest1** 的测试类，编辑后如下所示。

```java
package com.spring.instance.constructor;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class InstanceTest1 {
    @Test
    public void test() {
        // 定义Spring配置文件的路径
        String xmlPath = "com/spring/instance/constructor/ApplicationContext.xml";
        // 初始化Spring容器，加载配置文件，并对bean进行实例化
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(
                xmlPath);
        // 通过容器获取id为person1的实例
        System.out.println(applicationContext.getBean("person1"));
    }
}
```

#### 7.2.1.5 运行程序并查看结果

> com.spring.instance.constructor.Person1@52e6fdee

## 7.2.2 静态工厂方式实例化

#### 7.2.2.1 创建实体类
- 在项目的 src 目录下创建一个名为 **com.spring.instance.static_factory** 的包，并在该包下创建一个实体类 **Person2**。

```java
package com.spring.instance.static_factory;

public class Person2 {
}
```

#### 7.2.2.2 创建静态工厂类
- 在 **com.spring.instance.static_factory** 包下创建一个名为 **MyBeanFactory** 的类，并在该类中创建一个名为 **createBean()** 的静态方法，用于创建 Bean 的实例，如下所示。

```java
package com.spring.instance.static_factory;

public class MyBeanFactory {
    // 创建Bean实例的静态工厂方法
    public static Person2 createBean() {
        return new Person2();
    }
}
```

#### 7.2.2.3 创建 Spring 配置文件
- 在 **com.spring.instance.static_factory** 包下创建 Spring 的配置文件 **applicationContext.xml**，编辑后如下所示。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.2.xsd">
    <bean id="person2" class="com.spring.instance.static_factory.MyBeanFactory"
          factory-method="createBean" />
</beans>
```

#### 7.2.2.4 创建测试类
- 在 **com.spring.instance.static_factory** 包下创建一个名为 **InstanceTest2** 的测试类，编辑后如下所示。

```java
package com.spring.instance.static_factory;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class InstanceTest2 {
    @Test
    public void test() {
        // 定义Spring配置文件的路径
        String xmlPath = "com/spring/instance/static_factory/applicationContext.xml"; 
        // 初始化Spring容器，加载配置文件，并对bean进行实例化
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(
                xmlPath);
        // 通过容器获取id为person2实例
        System.out.println(applicationContext.getBean("person2"));
    }
}
```

#### 7.2.2.5 运行程序并查看结果
> com.spring.instance.static_factory.Person2@9f116cc

## 7.2.3 实例工厂方式实例化

#### 7.2.3.1 创建实体类
- 在项目的 src 目录下创建一个名为 **com.spring.instance.factory** 的包，在该包下创建一个 **Person3** 类。

```java
package com.spring.instance.factory;

public class Person3 {
}
```

#### 7.2.3.2 创建实例工厂类
- 在 **com.spring.instance.factory** 包下创建一个名为 **MyBeanFactory** 的类，编辑后如下所示。

```java
package com.spring.instance.factory;

public class MyBeanFactory {
    public MyBeanFactory() {
        System.out.println("person3工厂实例化中");
    }
    // 创建Bean的方法
    public Person3 createBean() {
        return new Person3();
    }
}
```

#### 7.2.3.3 创建 Spring 配置文件
- 在 **com.spring.instance.factory** 包下创建 Spring 的配置文件 **applicationContext.xml**，如下所示。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.2.xsd">
    <!-- 配置实例工厂 -->
    <bean id="myBeanFactory" class="com.spring.instance.factory.MyBeanFactory" />
    <!-- factory-bean属性指定一个实例工厂，factory-method属性确定使用工厂中的哪个方法 -->
    <bean id="person3" factory-bean="myBeanFactory" factory-method="createBean" />
</beans>
```

#### 7.2.3.4 创建测试类
- 在 **com.spring.instance.factory** 包下创建一个名为 **InstanceTest3** 的测试类，编辑后如下所示。

```java
package com.spring.instance.factory;

import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class InstanceTest3 {
    @Test
    public void test() {
        // 定义Spring配置文件的路径
        String xmlPath = "com/spring/instance/factory/applicationContext.xml"; 
        // 初始化Spring容器，加载配置文件，并对bean进行实例化
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(
                xmlPath);
        // 通过容器获取id为person3实例
        System.out.println(applicationContext.getBean("person3"));
    }
}
```

#### 7.2.3.5 运行程序并查看结果
> person3工厂实例化中  
com.spring.instance.factory.Person3@6c64cb25

## 7.3 Spring中Bean的作用域

<table>
  <thead>
    <tr>
      <th>作用域的种类</th>
      <th>说明</th>
    </tr>
  </thead>
    <tbody>
    <tr>
      <td>singleton</td>
      <td>单例模式，使用 singleton 定义的 Bean 在 Spring 容器中只有一个实例，这也是 Bean 默认的作用域。</td>
    </tr>
    <tr>
      <td>prototype</td>
      <td>原型模式，每次通过 Spring 容器获取 prototype 定义的 Bean 时，容器都将创建一个新的 Bean 实例。</td>
    </tr>
    <tr>
      <td>request</td>
      <td>在一次 HTTP 请求中，容器会返回该 Bean 的同一个实例。而对不同的 HTTP 请求，会返回不同的实例，该作用域仅在当前 HTTP Request 内有效。</td>
    </tr>
    <tr>
      <td>session</td>
      <td>在一次 HTTP Session 中，容器会返回该 Bean 的同一个实例。而对不同的 HTTP 请求，会返回不同的实例，该作用域仅在当前 HTTP Session 内有效。</td>
    </tr>
    <tr>
      <td>global Session</td>
      <td>在一个全局的 HTTP Session 中，容器会返回该 Bean 的同一个实例。该作用域仅在使用 portlet context 时有效。</td>
    </tr>
  </tbody>
</table>

### 7.3.1 singleton 作用域
#### 7.3.1.1 创建类
- 在项目的 src 目录下创建一个名为 **com.spring.scope** 的包，在该包下创建 **Person** 类，类中不需要添加任何成员。

#### 7.3.1.2 创建配置文件
- 创建 Spring 的配置文件 **applicationContext.xml**，编辑后如下所示。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.2.xsd">
    <bean id="person" class="com.spring.scope.Person" scope="singleton"/>
</beans>
```

#### 7.3.1.3 创建测试类
- 创建一个名为 PersonTest 的测试类，编辑后如下所示。

```java
package com.spring.scope;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class PersonTest {
    @Test
    public void test() {
        // 定义Spring配置文件路径
        String xmlPath = "com/spring/scope/applicationContext.xml";
        // 初始化Spring容器，加载配置文件，并对bean进行实例化
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(
                xmlPath);
        // 输出获得实例
        System.out.println(applicationContext.getBean("person"));
        System.out.println(applicationContext.getBean("person"));
    }
}
```

#### 7.3.1.4 运行程序并查看结果

> com.spring.scope.Person@52e6fdee  
com.spring.scope.Person@52e6fdee

### 7.3.2 prototype 作用域
#### 7.3.2.1 修改配置文件

```xml
<bean id="person" class="com.mengma.scope.Person" scope="prototype"/>
```

#### 7.3.2.2 运行程序并查看结果

> com.spring.scope.Person@59fd97a8  
com.spring.scope.Person@f5ac9e4

## 7.4 Spring Bean的生命周期
- 当一个 Bean 被加载到 Spring 容器时，它就具有了生命，而 Spring 容器在保证一个 Bean 能够使用之前，会进行很多工作。

![image](/assets/img/post_img/beanlife.png)

- Bean 生命周期的整个执行过程描述如下：

> 1. 根据配置情况调用 Bean 构造方法或工厂方法实例化 Bean。
> 2. 利用依赖注入完成 Bean 中所有属性值的配置注入。
> 3. 如果 Bean 实现了 BeanNameAware 接口，则 Spring 调用 Bean 的 setBeanName() 方法传入当前 Bean 的 id 值。
> 4. 如果 Bean 实现了 BeanFactoryAware 接口，则 Spring 调用 setBeanFactory() 方法传入当前工厂实例的引用。
> 5. 如果 Bean 实现了 ApplicationContextAware 接口，则 Spring 调用 setApplicationContext() 方法传入当前 ApplicationContext 实例的引用。
> 6. 如果 BeanPostProcessor 和 Bean 关联，则 Spring 将调用该接口的预初始化方法 postProcessBeforeInitialzation() 对 Bean 进行加工操作，此处非常重要，Spring 的 AOP 就是利用它实现的。
> 7. 如果 Bean 实现了 InitializingBean 接口，则 Spring 将调用 afterPropertiesSet() 方法。
> 8. 如果在配置文件中通过 init-method 属性指定了初始化方法，则调用该初始化方法。
> 9. 如果 BeanPostProcessor 和 Bean 关联，则 Spring 将调用该接口的初始化方法 postProcessAfterInitialization()。此时，Bean 已经可以被应用系统使用了。
> 10. 如果在 <bean> 中指定了该 Bean 的作用范围为 scope="singleton"，则将该 Bean 放入 Spring IoC 的缓存池中，将触发 Spring 对该 Bean 的生命周期管理；如果在 <bean> 中指定了该 Bean 的作用范围为 scope="prototype"，则将该 Bean 交给调用者，调用者管理该 Bean 的生命周期，Spring 不再管理该 Bean。
> 11. 如果 Bean 实现了 DisposableBean 接口，则 Spring 会调用 destory() 方法将 Spring 中的 Bean 销毁；如果在配置文件中通过 destory-method 属性指定了 Bean 的销毁方法，则 Spring 将调用该方法对 Bean 进行销毁。

## 7.5 Bean 的装配方式
### 7.5.1 Spring基于XML装配Bean
- Spring 基于 XML 的装配通常采用两种实现方式，即设值注入（Setter Injection）和构造注入（Constructor Injection）。本节将讲解如何在 XML 配置文件中使用这两种注入方式。

#### 7.5.1.1 创建 Person 类
- 在项目 springDemo02 中的 src 目录下，创建一个名称为 **com.spring.assembly** 的包，在该包下创建一个 **Person** 类，如下所示。

```java
package com.spring.assembly;

public class Person {
    private String name;
    private int age;
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
    // 重写toString()方法
    public String toString() {
        return "Person[name=" + name + ",age=" + age + "]";
    }
    // 默认无参的构造方法
    public Person() {
        super();
    }
    // 有参的构造方法
    public Person(String name, int age) {
        super();
        this.name = name;
        this.age = age;
    }
}
```

#### 7.5.1.2 创建 Spring 配置文件
- 在 **com.spring.assembly** 包下创建一个名为 **applicationContext.xml** 的配置文件，如下所示。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.2.xsd">
    <!-- 使用设值注入方式装配Person实例 -->
    <bean id="person1" class="com.spring.assembly.Person">
        <property name="name" value="zhangsan" />
        <property name="age" value="20" />
    </bean>
    <!-- 使用构造方法装配Person实例 -->
    <bean id="person2" class="com.spring.assembly.Person">
        <constructor-arg index="0" value="lisi" />
        <constructor-arg index="1" value="21" />
    </bean>
</beans>
```

#### 7.5.1.3 创建测试类
- 在 **com.spring.assembly** 包下创建一个名称为 **XmlBeanAssemblyTest** 的测试类，编辑后如下所示。

```java
package com.spring.assembly;

import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class XmlBeanAssemblyTest {
    @Test
    public void test() {
        // 定义Spring配置文件路径
        String xmlPath = "com/spring/assembly/applicationContext.xml";
        // 初始化Spring容器，加载配置文件，并对bean进行实例化
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(
                xmlPath);
        // 设值方式输出结果
        System.out.println(applicationContext.getBean("person1"));
        // 构造方式输出结果
        System.out.println(applicationContext.getBean("person2"));
    }
}
```

#### 7.5.1.4 运行项目并查看结果
> Person[name=zhangsan,age=20]  
Person[name=lisi,age=21]

### 7.5.2 Spring基于Annotation装配Bean
- 在 Spring 中，尽管使用 XML 配置文件可以实现 Bean 的装配工作，但如果应用中 Bean 的数量较多，会导致 XML 配置文件过于臃肿，从而给维护和升级带来一定的困难。

- 常用注解：

<table>
  <thead>
    <tr>
      <th>注解</th>
      <th>说明</th>
    </tr>
  </thead>
    <tbody>
    <tr>
      <td>@Component</td>
      <td>可以使用此注解描述 Spring 中的 Bean，但它是一个泛化的概念，仅仅表示一个组件（Bean），<br>并且可以作用在任何层次。使用时只需将该注解标注在相应类上即可。</td>
    </tr>
    <tr>
      <td>@Repository</td>
      <td>用于将数据访问层（DAO层）的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td>
    </tr>
    <tr>
      <td>@Service</td>
      <td>通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td>
    </tr>
    <tr>
      <td>@Controller</td>
      <td>通常作用在控制层（如 Struts2 的 Action），用于将控制层的类标识为 Spring 中的 Bean，<br>其功能与 @Component 相同。</td>
    </tr>
    <tr>
      <td>@Autowired</td>
      <td>用于对 Bean 的属性变量、属性的 Set 方法及构造函数进行标注，<br>配合对应的注解处理器完成 Bean 的自动配置工作。默认按照 Bean 的类型进行装配。</td>
    </tr>
    <tr>
      <td>@Resource</td>
      <td>其作用与 Autowired 一样。其区别在于 @Autowired 默认按照 Bean 类型装配，<br>而 @Resource 默认按照 Bean 实例名称进行装配。<br>@Resource 中有两个重要属性：name 和 type。<br>Spring 将 name 属性解析为 Bean 实例名称，type 属性解析为 Bean 实例类型。<br>如果指定 name 属性，则按实例名称进行装配；如果指定 type 属性，则按 Bean 类型进行装配。</td>
    </tr>
    <tr>
      <td>@Qualifier</td>
      <td>与 @Autowired 注解配合使用，会将默认的按 Bean 类型装配修改为按 Bean 的实例名称装配，<br>Bean 的实例名称由 @Qualifier 注解的参数指定。</td>
    </tr>
  </tbody>
</table>

#### 7.5.2.1 创建 DAO 层接口
- 在 src 目录下创建一个名为 **com.spring.annotation** 的包，在该包下创建一个名为 **PersonDao** 的接口，并添加一个 **add()** 方法，如下所示。

```java
package com.spring.annotation;

public interface PersonDao {
    public void add();
}
```

#### 7.5.2.2 创建 DAO 层接口的实现类
- 在 **com.spring.annotation** 包下创建 **PersonDao** 接口的实现类 **PersonDaoImpl**，编辑后如下所示。

```java
package com.spring.annotation;

import org.springframework.stereotype.Repository;
@Repository("personDao")
public class PersonDaoImpl implements PersonDao {
    @Override
    public void add() {
        System.out.println("Dao层的add()方法执行了...");
    }
}
```
- 首先使用 @Repository 注解将 PersonDaoImpl 类标识为 Spring 中的 Bean，其写法相当于配置文件中 <bean id="personDao"class="com.spring.annotation.PersonDaoImpl"/> 的书写。

#### 7.5.2.3 创建 Service 层接口
- 在 **com.spring.annotation** 包下创建一个名为 **PersonService** 的接口，并添加一个 **add()** 方法，如下所示。

```java
package com.spring.annotation;
public interface PersonService {
    public void add();
}
```

#### 7.5.2.4 创建 Service 层接口的实现类
- 在 **com.spring.annotation** 包下创建 **PersonService** 接口的实现类 **PersonServiceImpl**，编辑后如下所示。

```java
package com.spring.annotation;
import javax.annotation.Resource;
import org.springframework.stereotype.Service;
@Service("personService")
public class PersonServiceImpl implements PersonService {
    @Resource(name = "personDao")
    private PersonDao personDao;
    public PersonDao getPersonDao() {
        return personDao;
    }
    @Override
    public void add() {
        personDao.add();// 调用personDao中的add()方法
        System.out.println("Service层的add()方法执行了...");
    }
}
```
- 首先使用 @Service 注解将 PersonServiceImpl 类标识为 Spring 中的 Bean，其写法相当于配置文件中 <bean id="personService"class="com.spring.annotation.PersonServiceImpl"/> 的书写。
- 然后使用 @Resource 注解标注在属性 personDao 上（也可标注在 personDao 的 setPersonDao() 方法上），这相当于配置文件中 <property name="personDao"ref="personDao"/> 的写法。

#### 7.5.2.5 创建 Action
- 在 **com.spring.annotation** 包下创建一个名为 **PersonAction** 的类，编辑后如下所示。 

```java
package com.spring.annotation;

import javax.annotation.Resource;
import org.springframework.stereotype.Controller;
@Controller("personAction")
public class PersonAction {
    @Resource(name = "personService")
    private PersonService personService;
    public PersonService getPersonService() {
        return personService;
    }
    public void add() {
        personService.add(); // 调用personService中的add()方法
        System.out.println("Action层的add()方法执行了...");
    }
}
```
- 首先使用 @Controller 注解标注 PersonAction 类，其写法相当于在配置文件中编写 <bean id="personAction"class="com.mengma.annotation.PersonAction"/>。
- 然后使用了 @Resource 注解标注在 personService 上，这相当于在配置文件内编写 <property name="personService"ref="personService"/>。

#### 7.5.2.6 创建 Spring 配置文件
- 在 **com.spring.annotation** 包下创建一个名为 **applicationContext.xml** 的配置文件，如下所示。

```java
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:p="http://www.springframework.org/schema/p"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="
            http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
            http://www.springframework.org/schema/aop
            http://www.springframework.org/schema/aop/spring-aop-2.5.xsd
            http://www.springframework.org/schema/tx
            http://www.springframework.org/schema/tx/spring-tx-2.5.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd">
    <!--使用context命名空间，通知spring扫描指定目录，进行注解的解析-->
    <context:component-scan base-package="com.spring.annotation"/>
</beans>
```

#### 7.5.2.7 创建测试类
- 在 **com.spring.annotation** 包下创建一个名为 **AnnotationTest** 的测试类，编辑后如下所示。

```java
package com.spring.annotation;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class AnnotationTest {
    @Test
    public void test() {
        // 定义Spring配置文件路径
        String xmlPath = "com/spring/annotation/applicationContext.xml";
        // 初始化Spring容器，加载配置文件，并对bean进行实例化
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(
                xmlPath);
        // 获得personAction实例
        PersonAction personAction = (PersonAction) applicationContext
                .getBean("personAction");
        // 调用personAction中的add()方法
        personAction.add();
    }
}
```

#### 7.5.2.8 运行程序并查看结果
> Dao层的add()方法执行了...  
Service层的add()方法执行了...  
Action层的add()方法执行了...

### 7.5.3 Spring自动装配Bean
- 自动装配就是指 Spring 容器可以自动装配（autowire）相互协作的 Bean 之间的关联关系，将一个 Bean 注入其他 Bean 的 Property 中。
- 要使用自动装配，就需要配置 <bean> 元素的 autowire 属性。
- autowire的属性和作用：

<table>
  <thead>
    <tr>
      <th>名称</th>
      <th>说明</th>
    </tr>
  </thead>
    <tbody>
    <tr>
      <td>byName</td>
      <td>根据Property的name自动装配，如果一个Bean的name和另一个Bean中的Property的name相同，则自动装配这个Bean到Property中。</td>
    </tr>
    <tr>
      <td>byType</td>
      <td>根据Property的数据类型（Type）自动装配，如果一个Bean的数据类型兼容另一个Bean中Property的数据类型，则自动装配。</td>
    </tr>
    <tr>
      <td>constructor</td>
      <td>根据构造方法的参数的数据类型，进行byType模式的自动装配。</td>
    </tr>
    <tr>
      <td>autodetect</td>
      <td>如果发现默认的构造方法，则用constructor模式，否则用byType模式。</td>
    </tr>
    <tr>
      <td>no</td>
      <td>默认情况下，不使用自动装配，Bean依赖必须通过ref元素定义</td>
    </tr>
  </tbody>
</table>

#### 7.5.3.1 创建包
- 在 src 目录下创建一个名为 **com.spring.autowire** 的包，将基于注解装配包 **com.spring.annotation** 中的所有文件拷贝，在此基础上修改为自动装配。

> 注意将各个包含路径“ com/spring/annotation ”的地方修改为“ com/spring/autowire ”。

#### 7.5.3.2 修改PersonAction类和PersonServiceImpl类
- 分别添加各自的setter方法。

```java
package com.spring.autowire;

import org.springframework.stereotype.Controller;
import javax.annotation.Resource;

@Controller("personAction")
public class PersonAction {
    @Resource(name = "personService")
    private PersonService personService;
    public PersonService getPersonService() {
        return personService;
    }

    public void setPersonService(PersonService personService) {
        this.personService = personService;
    }

    public void add() {
        personService.add(); // 调用personService中的add()方法
        System.out.println("Action层的add()方法执行了...");
    }
}
```

```java
package com.spring.autowire;

import org.springframework.stereotype.Service;
import javax.annotation.Resource;

@Service("personService")
public class PersonServiceImpl implements PersonService {
    @Resource(name = "personDao")
    private PersonDao personDao;
    public PersonDao getPersonDao() {
        return personDao;
    }

    public void setPersonDao(PersonDao personDao) {
        this.personDao = personDao;
    }

    @Override
    public void add() {
        personDao.add();// 调用personDao中的add()方法
        System.out.println("Service层的add()方法执行了...");
    }

}
```

#### 7.5.3.3 修改 Spring 配置文件
- 将 **applicationContext.xml** 修改为如下所示。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">
    <bean id="personDao" class="com.spring.autowire.PersonDaoImpl" />
    <bean id="personService" class="com.spring.autowire.PersonServiceImpl"
          autowire="byName" />
    <bean id="personAction" class="com.spring.autowire.PersonAction"
          autowire="byName" />
</beans>
```
- 在上述配置文件中，用于配置 personService 和 personAction 的 <bean> 元素中除了 id 和 class 属性以外，还增加了 autowire 属性，并将其属性值设置为 byName（按属性名称自动装配）。
- 默认情况下，配置文件中需要通过 ref 装配 Bean，但设置了 autowire="byName"，Spring 会在配置文件中自动寻找与属性名字 personDao 相同的 <bean>，找到后，通过调用 setPersonDao（PersonDao personDao）方法将 id 为 personDao 的 Bean 注入 id 为 personService 的 Bean 中，这时就不需要通过 ref 装配了。

#### 7.5.3.4 运行程序并查看结果

> Dao层的add()方法执行了...  
Service层的add()方法执行了...  
Action层的add()方法执行了...

---

# 第8章 Spring AOP
## 8.1 AOP的概念
- AOP的全称是 Aspect-Oriented Programming，即面向切面编程。它是面向对象编程（OOP）的一种补充。
- AOP采取横向抽取机制，将分散在各个方法中的重复代码提取出来，然后在程序编译或运行时，再将这些提取出来的代码应用到需要执行的地方。
- AOP 的相关术语：

<table>
  <thead>
    <tr>
      <th>名称</th>
      <th>说明</th>
    </tr>
  </thead>
    <tbody>
    <tr>
      <td>Joinpoint（连接点）</td>
      <td>指那些被拦截到的点，在 Spring 中，可以被动态代理拦截目标类的方法。</td>
    </tr>
    <tr>
      <td>Pointcut（切入点）</td>
      <td>指要对哪些 Joinpoint 进行拦截，即被拦截的连接点。</td>
    </tr>
    <tr>
      <td>Advice（通知）</td>
      <td>指拦截到 Joinpoint 之后要做的事情，即对切入点增强的内容。</td>
    </tr>
    <tr>
      <td>Target（目标）</td>
      <td>指代理的目标对象。</td>
    </tr>
    <tr>
      <td>Weaving（植入）</td>
      <td>指把增强代码应用到目标上，生成代理对象的过程。</td>
    </tr>
    <tr>
      <td>Proxy（代理）</td>
      <td>指生成的代理对象。</td>
    </tr>
    <tr>
      <td>Aspect（切面）</td>
      <td>切入点和通知的结合。</td>
    </tr>
  </tbody>
</table>

## 8.2 Spring JDK动态代理
- JDK 动态代理是通过 JDK 中的 **java.lang.reflect.Proxy** 类实现的。

### 8.2.1 JDK 动态代理的示例

#### 8.2.1.1 创建项目
- 在 IDEA 中创建一个名称为 springDemo03 的 Web 项目，将 Spring 支持和依赖的 JAR 包复制到 Web 项目的 WEB-INF/lib 目录中，并发布到类路径下。

> com.springsource.org.aopalliance-1.0.0.jar  
  com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar  
  commons-logging-1.2.jar  
  mysql-connector-java-8.0.20.jar  
  spring-aop-4.3.6.RELEASE.jar  
  spring-aspects-4.3.6.RELEASE.jar  
  spring-beans-4.3.6.RELEASE.jar  
  spring-context-4.3.6.RELEASE.jar  
  spring-core-4.3.6.RELEASE.jar  
  spring-expression-4.3.6.RELEASE.jar  
  spring-tx-4.3.6.RELEASE.jar  

#### 8.2.1.2 创建接口 CustomerDao
- 在项目的 src 目录下创建一个名为 **com.spring.dao** 的包，在该包下创建一个 **CustomerDao** 接口，编辑后如下所示。

```java
package com.spring.dao;

public interface CustomerDao {
    public void add(); // 添加
    public void update(); // 修改
    public void delete(); // 删除
    public void find(); // 查询
}
```

#### 8.2.1.3 创建实现类 CustomerDaoImpl
- 在 **com.spring.dao** 包下创建 **CustomerDao** 接口的实现类 **CustomerDaoImpl**，并实现该接口中的所有方法，如下所示。

```java
package com.spring.dao;

public class CustomerDaoImpl implements CustomerDao {
    @Override
    public void add() {
        System.out.println("添加客户...");
    }
    @Override
    public void update() {
        System.out.println("修改客户...");
    }
    @Override
    public void delete() {
        System.out.println("删除客户...");
    }
    @Override
    public void find() {
        System.out.println("修改客户...");
    }
}
```

#### 8.2.1.4 创建切面类 MyAspect
- 在 src 目录下，创建一个名为 **com.spring.jdk** 的包，在该包下创建一个切面类 **MyAspect**，编辑后如下所示。

```java
package com.spring.jdk;
public class MyAspect {
    public void myBefore() {
        System.out.println("方法执行之前");
    }
    public void myAfter() {
        System.out.println("方法执行之后");
    }
}
```

- 在切面中定义了两个增强的方法，分别为 myBefore() 方法和 myAfter() 方法，用于对目标类（CustomerDaoImpl）进行增强。

#### 8.2.1.5 创建代理类 MyBeanFactory
- 在 **com.spring.jdk** 包下创建一个名为 **MyBeanFactory** 的类，在该类中使用 java.lang.reflect.Proxy 实现 JDK 动态代理，如下所示。

```java 
package com.spring.jdk;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import com.spring.dao.CustomerDao;
import com.spring.dao.CustomerDaoImpl;
public class MyBeanFactory {
    public static CustomerDao getBean() {
        // 准备目标类
        final CustomerDao customerDao = new CustomerDaoImpl();
        // 创建切面类实例
        final MyAspect myAspect = new MyAspect();
        // 使用代理类，进行增强
        return (CustomerDao) Proxy.newProxyInstance(
                MyBeanFactory.class.getClassLoader(),
                new Class[] { CustomerDao.class }, new InvocationHandler() {
                    public Object invoke(Object proxy, Method method,
                                         Object[] args) throws Throwable {
                        myAspect.myBefore(); // 前增强
                        Object obj = method.invoke(customerDao, args);
                        myAspect.myAfter(); // 后增强
                        return obj;
                    }
                });
                
/** 使用代理类对创建的实例 customerDao 中的方法进行增强，
  * 其中 Proxy 的 newProxyInstance()方法的  
  * 第一个参数是当前类的类加载器，
  * 第二参数是所创建实例的实现类的接口，
  * 第三个参数就是需要增强的方法。
  */
    }
}
```

#### 8.2.1.6 创建测试类 JDKProxyTest
- 在 **com.spring.jdk** 包下创建一个名为 **JDKProxyTest** 的测试类，如下所示。

```java
package com.spring.jdk;
import org.junit.Test;
import com.spring.dao.CustomerDao;
public class JDKProxyTest {
    @Test
    public void test() {
        // 从工厂获得指定的内容（相当于spring获得，但此内容时代理对象）
        CustomerDao customerDao = MyBeanFactory.getBean();
        // 执行方法
        customerDao.add();
        customerDao.update();
        customerDao.delete();
        customerDao.find();
    }
}
```
- 上述代码中，在调用 getBean() 方法时，获取的是 CustomerDao 类的代理对象，然后调用了该对象中的方法。

#### 8.2.1.7 运行项目并查看结果
> 方法执行之前  
添加客户...  
方法执行之后  
方法执行之前  
修改客户...  
方法执行之后  
方法执行之前  
删除客户...  
方法执行之后  
方法执行之前  
修改客户...  
方法执行之后  

## 8.3 Spring CGLIB动态代理
### 8.3.1 CGLIB 动态代理的示例

#### 8.3.1.1 创建目标类 GoodsDao
- 在 **com.spring.dao** 包下创建目标类 **GoodsDao**，在类中定义增、删、改、查方法，并在每个方法编写输出语句，如下所示。

```java
package com.spring.dao;
public class GoodsDao {
    public void add() {
        System.out.println("添加商品...");
    }
    public void update() {
        System.out.println("修改商品...");
    }
    public void delete() {
        System.out.println("删除商品...");
    }
    public void find() {
        System.out.println("修改商品...");
    }
}
```

#### 8.3.1.2 创建代理类 MyBeanFactory
- 在 src 目录下创建一个名为 **com.spring.cglib** 的包，该包下创建类 **MyBeanFactory**，如下所示。

```java
package com.spring.cglib;
import java.lang.reflect.Method;
import org.springframework.cglib.proxy.Enhancer;
import org.springframework.cglib.proxy.MethodInterceptor;
import org.springframework.cglib.proxy.MethodProxy;
import com.spring.dao.GoodsDao;
import com.spring.jdk.MyAspect;
public class MyBeanFactory {
    public static GoodsDao getBean() {
        // 准备目标类
        final GoodsDao goodsDao = new GoodsDao();
        // 创建切面类实例
        final MyAspect myAspect = new MyAspect();
        // 生成代理类，CGLIB在运行时，生成指定对象的子类，增强
        Enhancer enhancer = new Enhancer();
        // 确定需要增强的类
        enhancer.setSuperclass(goodsDao.getClass());
        // 添加回调函数
        enhancer.setCallback(new MethodInterceptor() {
            // intercept 相当于 jdk invoke，前三个参数与 jdk invoke—致
            @Override
            public Object intercept(Object proxy, Method method, Object[] args,
                                    MethodProxy methodProxy) throws Throwable {
                myAspect.myBefore(); // 前增强
                Object obj = method.invoke(goodsDao, args); // 目标方法执行
                myAspect.myAfter(); // 后增强
                return obj;
            }
        });
        // 创建代理类
        GoodsDao goodsDaoProxy = (GoodsDao) enhancer.create();
        return goodsDaoProxy;
    }
}
```

#### 8.3.1.3 创建测试类
- 在 **com.spring.cglib** 包下创建测试类 **CGLIBProxyTest**，编辑后如下所示。

```java
package com.spring.cglib;
import org.junit.Test;
import com.spring.dao.GoodsDao;
public class CGLIBProxyTest {
    @Test
    public void test() {
        // 从工厂获得指定的内容（相当于spring获得，但此内容时代理对象）
        GoodsDao goodsDao = MyBeanFactory.getBean();
        // 执行方法
        goodsDao.add();
        goodsDao.update();
        goodsDao.delete();
        goodsDao.find();
    }
}
```

#### 8.3.1.4 运行项目并查看结果

> 方法执行之前  
添加商品...  
方法执行之后  
方法执行之前  
修改商品...  
方法执行之后  
方法执行之前  
删除商品...  
方法执行之后  
方法执行之前  
修改商品...  
方法执行之后  

## 8.4 Spring 通知类型及创建AOP代理

### 8.4.1 Spring 通知类型
- Spring 通知按照在目标类方法的连接点位置，可以分为以下五种类型：

<table>
  <thead>
    <tr>
      <th>名称</th>
      <th>说明</th>
    </tr>
  </thead>
    <tbody>
    <tr>
      <td>前置通知</td>
      <td>org.springframework.aop.MethodBeforeAdvice<br>在方法之前自动执行的通知称为前置通知，可以应用于权限管理等功能。</td>
    </tr>
    <tr>
      <td>后置通知</td>
      <td>org.springframework.aop.AfterReturningAdvice<br>在方法之后自动执行的通知称为后置通知，可以应用于关闭流、上传文件、删除临时文件等功能。</td>
    </tr>
    <tr>
      <td>环绕通知</td>
      <td>org.aopalliance.intercept.MethodInterceptor<br>在方法前后自动执行的通知称为环绕通知，可以应用于日志、事务管理等功能。</td>
    </tr>
    <tr>
      <td>异常通知</td>
      <td>org.springframework.aop.ThrowsAdvice<br>在方法抛出异常时自动执行的通知称为异常通知，可以应用于处理异常记录日志等功能。</td>
    </tr>
    <tr>
      <td>引介通知</td>
      <td>org.springframework.aop.IntroductionInterceptor<br>在目标类中添加一些新的方法和属性，可以应用于修改旧版本程序（增强类）。</td>
    </tr>
  </tbody>
</table>

### 8.4.2 声明式 Spring AOP
- Spring 创建一个 AOP 代理的基本方法是使用 org.springframework.aop.framework.ProxyFactoryBean，这个类对应的切入点和通知提供了完整的控制能力，并可以生成指定的内容。
- ProxyFactoryBean是FactoryBean接口的实现类，FactoryBean负责实例化一个Bean，而ProxyFactoryBean负责为其他Bean创建代理实例。
- ProxyFactoryBean 的常用属性： 

<table>
  <thead>
    <tr>
      <th>属性名称</th>
      <th>描述</th>
    </tr>
  </thead>
    <tbody>
    <tr>
      <td>target</td>
      <td>代理的目标对象</td>
    </tr>
    <tr>
      <td>proxyInterfaces</td>
      <td>代理要实现的接口，如果有多个接口，则可以使用以下格式赋值：
        <br>&lt;list&gt;
        <br>&lt;value&gt;&lt;/value&gt;
        <br>...
        <br>&lt;/list&gt;</td>
    </tr>
    <tr>
      <td>proxyTargetClass</td>
      <td>是否对类代理而不是接口，设置为 true 时，使用 CGLIB 代理</td>
    </tr>
    <tr>
      <td>interceptorNames</td>
      <td>需要植入目标的 Advice</td>
    </tr>
    <tr>
      <td>singleton</td>
      <td>返回的代理是否为单例，默认为 true（返回单实例）</td>
    </tr>
    <tr>
      <td>optimize</td>
      <td>当设置为 true 时，强制使用 CGLIB</td>
    </tr>
  </tbody>
</table>

- 在 Spring 通知中，环绕通知是一个非常典型的应用。下面通过环绕通知的案例演示 Spring 创建 AOP 代理的过程。

#### 8.4.2.1 创建切面类 MyAspect
- 在 src 目录下创建一个名为 **com.spring.factorybean** 的包，在该包下创建切面类 **MyAspect**，如下所示。

```java
package com.spring.factorybean;
import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;
//需要实现接口，确定哪个通知，及告诉Spring应该执行哪个方法
public class MyAspect implements MethodInterceptor {
    public Object invoke(MethodInvocation mi) throws Throwable {
        System.out.println("方法执行之前");
        // 执行目标方法
        Object obj = mi.proceed();
        System.out.println("方法执行之后");
        return obj;
    }
}
```
- MyAspect 类实现了 MethodInterceptor 接口，并实现了接口的 invoke() 方法。MethodInterceptor 接口是 Spring AOP 的 JAR 包提供的，而 invoke() 方法用于确定目标方法 mi，并告诉 Spring 要在目标方法前后执行哪些方法，这里为了演示效果在目标方法前后分别向控制台输出了相应语句。

#### 8.4.2.2 创建 Spring 配置文件
- 在 **com.spring.factorybean** 包下创建配置文件 **applicationContext.xml**，如下所示。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!--目标类 -->
    <bean id="customerDao" class="com.spring.dao.CustomerDaoImpl" />
    <!-- 通知 advice -->
    <bean id="myAspect" class="com.spring.factorybean.MyAspect" />
    <!--生成代理对象 -->
    <bean id="customerDaoProxy"
          class="org.springframework.aop.framework.ProxyFactoryBean">
        <!--代理实现的接口 -->
        <property name="proxyInterfaces" value="com.spring.dao.CustomerDao" />
        <!--代理的目标对象 -->
        <property name="target" ref="customerDao" />
        <!--用通知增强目标 -->
        <property name="interceptorNames" value="myAspect" />
        <!-- 如何生成代理，true:使用cglib; false :使用jdk动态代理 -->
        <property name="proxyTargetClass" value="true" />
    </bean>
</beans>
```

#### 8.4.2.3 创建测试类
- 在 **com.spring.factorybean** 包下创建一个名为 **FactoryBeanTest** 的测试类，编辑后如下所示。

```java
package com.spring.factorybean;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import com.spring.dao.CustomerDao;
public class FactoryBeanTest {
    @Test
    public void test() {
        String xmlPath = "com/spring/factorybean/applicationContext.xml";
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(
                xmlPath);
        CustomerDao customerDao = (CustomerDao) applicationContext
                .getBean("customerDaoProxy");
        customerDao.add();
        customerDao.update();
        customerDao.delete();
        customerDao.find();
    }
}
```

#### 8.4.2.4 运行项目并查看结果
> 方法执行之前  
添加客户...  
方法执行之后  
方法执行之前  
修改客户...  
方法执行之后  
方法执行之前  
删除客户...  
方法执行之后  
方法执行之前  
修改客户...  
方法执行之后  

## 8.5 使用AspectJ开发AOP
- 新版本的 Spring 框架，建议使用 AspectJ 方式开发 AOP。
- 使用 AspectJ 开发 AOP 通常有两种方式：

> 基于 XML 的声明式。  
> 基于 Annotation 的声明式。

### 8.5.1 基于XML的声明式
- 基于 XML 的声明式是指通过 Spring 配置文件的方式定义切面、切入点及声明通知，而所有的切面和通知都必须定义在 <aop:config> 元素中。

#### 8.5.1.1 创建切面类 MyAspect
- 在 src 目录下创建一个名为 **com.spring.aspectj.xml** 的包，在该包下创建切面类 **MyAspect**，编辑后如下所示。

```java
package com.spring.aspectj.xml;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
//切面类
public class MyAspect {
    // 前置通知
    public void myBefore(JoinPoint joinPoint) {
        System.out.print("前置通知，目标：");
        System.out.print(joinPoint.getTarget() + "方法名称:");
        System.out.println(joinPoint.getSignature().getName());
    }
    // 后置通知
    public void myAfterReturning(JoinPoint joinPoint) {
        System.out.print("后置通知，方法名称：" + joinPoint.getSignature().getName());
    }
    // 环绕通知
    public Object myAround(ProceedingJoinPoint proceedingJoinPoint)
            throws Throwable {
        System.out.println("环绕开始"); // 开始
        Object obj = proceedingJoinPoint.proceed(); // 执行当前目标方法
        System.out.println("环绕结束"); // 结束
        return obj;
    }
    // 异常通知
    public void myAfterThrowing(JoinPoint joinPoint, Throwable e) {
        System.out.println("异常通知" + "出错了" + e.getMessage());
    }
    // 最终通知
    public void myAfter() {
        System.out.println("最终通知");
    }
}
```

- 上述代码中，分别定义了几种不同的通知类型方法，在这些方法中，通过 JoinPoint 参数可以获得目标对象的类名、目标方法名和目标方法参数等。需要注意的是，环绕通知必须接收一个类型为 ProceedingJoinPoint 的参数，返回值必须是 Object 类型，且必须抛出异常。异常通知中可以传入 Throwable 类型的参数，用于输出异常信息。

#### 8.5.1.2 创建 Spring 配置文件
- 在 **com.spring.aspectj.xml** 包下创建 **applicationContext.xml** 的配置文件，如下所示。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="
            http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
            http://www.springframework.org/schema/aop
            http://www.springframework.org/schema/aop/spring-aop-2.5.xsd">
    <!--目标类 -->
    <bean id="customerDao" class="com.spring.dao.CustomerDaoImpl" />
    <!--切面类 -->
    <bean id="myAspect" class="com.spring.aspectj.xml.MyAspect"></bean>
    <!--AOP 编程 -->
    <aop:config>
        <aop:aspect ref="myAspect">
            <!-- 配置切入点，通知最后增强哪些方法 -->
            <aop:pointcut expression="execution ( * com.spring.dao.*.* (..))"
                          id="myPointCut" />
            <!--前置通知，关联通知 Advice和切入点PointCut -->
            <aop:before method="myBefore" pointcut-ref="myPointCut" />
            <!--后置通知，在方法返回之后执行，就可以获得返回值returning 属性 -->
            <aop:after-returning method="myAfterReturning"
                                 pointcut-ref="myPointCut" returning="returnVal" />
            <!--环绕通知 -->
            <aop:around method="myAround" pointcut-ref="myPointCut" />
            <!--抛出通知：用于处理程序发生异常，可以接收当前方法产生的异常 -->
            <!-- *注意：如果程序没有异常，则不会执行增强 -->
            <!-- * throwing属性：用于设置通知第二个参数的名称，类型Throwable -->
            <aop:after-throwing method="myAfterThrowing"
                                pointcut-ref="myPointCut" throwing="e" />
            <!--最终通知：无论程序发生任何事情，都将执行 -->
            <aop:after method="myAfter" pointcut-ref="myPointCut" />
        </aop:aspect>
    </aop:config>
</beans>
```

#### 8.5.1.3 创建测试类
- 在 **com.spring.aspectj.xml** 包下创建测试类 **XMLTest**，如下所示。

```java
package com.spring.aspectj.xml;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import com.spring.dao.CustomerDao;
public class XMLTest {
    @Test
    public void test() {
        String xmlPath = "com/spring/aspectj/xml/applicationContext.xml";
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(
                xmlPath);
        // 从spring容器获取实例
        CustomerDao customerDao = (CustomerDao) applicationContext
                .getBean("customerDao");
        // 执行方法
        customerDao.add();
    }
}
```

#### 8.5.1.4  运行项目并查看结果

> 前置通知，目标：com.spring.dao.CustomerDaoImpl@50029372方法名称:add  
环绕开始  
添加客户...  
最终通知  
环绕结束  
后置通知，方法名称：add  

- 为了更好地演示异常通知，接下来在 CustomerDaoImpl 类的 add() 方法中添加一行会抛出异常的代码，如“int i=1/0;”，重新运行 XMLTest 测试类，可以看到异常通知执行了，此时控制台的输出结果如下所示。

> 前置通知，目标：com.spring.dao.CustomerDaoImpl@28194a50方法名称:add  
环绕开始  
最终通知  
异常通知出错了/ by zero

### 8.5.2 基于 Annotation 的声明式
- AspectJ 允许使用注解定义切面、切入点和增强处理，而 Spring 框架则可以识别并根据这些注解生成 AOP 代理。
- Annotation 注解介绍：

<table>
  <thead>
    <tr>
      <th>名称</th>
      <th>说明</th>
    </tr>
  </thead>
    <tbody>
    <tr>
      <td>@Aspect</td>
      <td>用于定义一个切面。</td>
    </tr>
    <tr>
      <td>@Before</td>
      <td>用于定义前置通知，相当于 BeforeAdvice。</td>
    </tr>
    <tr>
      <td>@AfterReturning</td>
      <td>用于定义后置通知，相当于 AfterReturningAdvice。</td>
    </tr>
    <tr>
      <td>@Around</td>
      <td>用于定义环绕通知，相当于MethodInterceptor。</td>
    </tr>
    <tr>
      <td>@AfterThrowing</td>
      <td>用于定义抛出通知，相当于ThrowAdvice。</td>
    </tr>
    <tr>
      <td>@After</td>
      <td>用于定义最终final通知，不管是否异常，该通知都会执行。</td>
    </tr>
    <tr>
      <td>@DeclareParents</td>
      <td>用于定义引介通知，相当于IntroductionInterceptor（不要求掌握）。</td>
    </tr>
  </tbody>
</table>    

#### 8.5.2.1 创建切面类 MyAspect

```java
package com.spring.aspectj.annotation;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.AfterThrowing;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;
//切面类
@Aspect
@Component
public class MyAspect {
    // 用于取代：<aop:pointcut
    // expression="execution(*com.mengma.dao..*.*(..))" id="myPointCut"/>
    // 要求：方法必须是private，没有值，名称自定义，没有参数
    @Pointcut("execution(*com.mengma.dao..*.*(..))")
    private void myPointCut() {
    }
    // 前置通知
    @Before("myPointCut()")
    public void myBefore(JoinPoint joinPoint) {
        System.out.print("前置通知，目标：");
        System.out.print(joinPoint.getTarget() + "方法名称:");
        System.out.println(joinPoint.getSignature().getName());
    }
    // 后置通知
    @AfterReturning(value = "myPointCut()")
    public void myAfterReturning(JoinPoint joinPoint) {
        System.out.print("后置通知，方法名称：" + joinPoint.getSignature().getName());
    }
    // 环绕通知
    @Around("myPointCut()")
    public Object myAround(ProceedingJoinPoint proceedingJoinPoint)
            throws Throwable {
        System.out.println("环绕开始"); // 开始
        Object obj = proceedingJoinPoint.proceed(); // 执行当前目标方法
        System.out.println("环绕结束"); // 结束
        return obj;
    }
    // 异常通知
    @AfterThrowing(value = "myPointCut()", throwing = "e")
    public void myAfterThrowing(JoinPoint joinPoint, Throwable e) {
        System.out.println("异常通知" + "出错了" + e.getMessage());
    }
    // 最终通知
    @After("myPointCut()")
    public void myAfter() {
        System.out.println("最终通知");
    }
}
```
- @Aspect 注解用于声明这是一个切面类，该类作为组件使用，所以要添加 @Component 注解才能生效。
- @Poincut 注解用于配置切入点，取代 XML 文件中配置切入点的代码。

#### 8.5.2.2 为目标类添加注解
- 在 **com.spring.dao.CustomerDaoImpl** 目标类中添加注解 **@Repository("customerDao")**。

#### 8.5.2.3 创建Spring配置文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
            http://www.springframework.org/schema/aop
            http://www.springframework.org/schema/aop/spring-aop-2.5.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd">
    <!--扫描含com.spring包下的所有注解-->
    <context:component-scan base-package="com.spring"/>
    <!-- 使切面开启自动代理 -->
    <aop:aspectj-autoproxy></aop:aspectj-autoproxy>
</beans>
```

#### 8.5.2.4 创建测试类
- 在 **com.spring.aspectj.annotation** 包下创建一个名为 **AnnotationTest** 的测试类，如下所示。

```java
package com.spring.aspectj.annotation;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import com.spring.dao.CustomerDao;
public class AnnotationTest {
    @Test
    public void test() {
        String xmlPath = "com/spring/aspectj/xml/applicationContext.xml";
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(
                xmlPath);
        // 从spring容器获取实例
        CustomerDao customerDao = (CustomerDao) applicationContext
                .getBean("customerDao");
        // 执行方法
        customerDao.add();
    }
}
```

#### 8.5.2.5 运行项目并查看结果
> 前置通知，目标：com.spring.dao.CustomerDaoImpl@4b8729ff方法名称:add  
环绕开始  
添加客户...  
最终通知  
环绕结束  
后置通知，方法名称：add  

---

# 第9章 Spring JDBC 与事务管理

## 9.1 Spring JDBC
- Spring 框架针对数据库开发中的应用提供了 JDBCTemplate 类，该类是 Spring 对 JDBC 支持的核心，它提供了所有对数据库操作功能的支持。
- Spring 框架提供的JDBC支持主要由四个包组成，分别是 core（核心包）、object（对象包）、dataSource（数据源包）和 support（支持包）。

## 9.2 事务管理
- Spring 的事务管理有两种方式：一种是传统的编程式事务管理，即通过编写代码实现的事务管理；另一种是基于 AOP 技术实现的声明式事务管理。由于在实际开发中，编程式事务管理很少使用，所以我们只对 Spring 的声明式事务管理进行详细讲解。
- Spring 实现声明式事务管理主要有两种方式：

> 基于 XML 方式的声明式事务管理。  
通过 Annotation 注解方式的事务管理。

### 9.2.1 基于 XML 方式的事务管理

#### 9.2.1.1 创建项目
- 在 IDEA 中创建一个名为 springDemo04 的 Web 项目，将 Spring 支持和依赖的 JAR 包复制到 Web 项目的 lib 目录中，并添加到类路径下。

> com.springsource.com.mchange.v2.c3p0-0.9.1.2.jar  
  com.springsource.org.aopalliance-1.0.0.jar  
  com.springsource.org.apache.commons.logging-1.1.1.jar  
  com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar  
  commons-logging-1.2.jar  
  mysql-connector-java-8.0.20.jar  
  spring-aop-4.3.6.RELEASE.jar  
  spring-aspects-4.3.6.RELEASE.jar  
  spring-beans-4.3.6.RELEASE.jar  
  spring-context-4.3.6.RELEASE.jar  
  spring-core-4.3.6.RELEASE.jar  
  spring-expression-4.3.6.RELEASE.jar  
  spring-jdbc-4.1.2.RELEASE.jar  
  spring-test-3.2.13.RELEASE.jar  
  spring-tx-4.3.6.RELEASE.jar  
  
#### 9.2.1.2 创建数据库、表以及插入数据
- 在 MySQL 中创建一个名为 *spring* 的数据库，然后在该数据库中创建一个 **account** 表，并向表中插入两条数据，其 SQL 执行语句如下所示：

```sql
CREATE DATABASE spring;
USE spring;
CREATE TABLE account (
    id INT (11) PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(20) NOT NULL,
    money INT DEFAULT NULL
);
INSERT INTO account VALUES (1,'zhangsan',1000);
INSERT INTO account VALUES (2,'lisi',1000);
```

<table>
  <thead>
    <tr>
      <th>id</th>
      <th>username</th>
      <th>money</th>
    </tr>
  </thead>
    <tbody>
    <tr>
      <td>1</td>
      <td>zhangsan</td>
      <td>1000</td>
    </tr>
    <tr>
      <td>2</td>
      <td>lisi</td>
      <td>1000</td>
    </tr>
  </tbody>
</table>   

#### 9.2.1.3 创建 c3p0-db.properties
- 在项目的 src 下创建一个名为 c3p0-db.properties 的配置文件，这里使用 C3P0 数据源，需要在该文件中添加如下配置：

```java
jdbc.driverClass = com.mysql.cj.jdbc.Driver
jdbc.jdbcUrl = jdbc:mysql://localhost:3306/spring?serverTimezone=UTC
jdbc.user = root
jdbc.password = root
```

#### 9.2.1.4 实现 DAO
##### 9.2.1.4.1 创建 AccountDao 接口
- 在项目的 src 目录下创建一个名为 **com.spring.dao** 的包，在该包下创建一个接口 **AccountDao**，并在接口中创建汇款和收款的方法，如下所示。

```java
package com.spring.dao;
public interface AccountDao {
    // 汇款
    public void out(String outUser, int money);
    // 收款
    public void in(String inUser, int money);
}
```

##### 9.2.1.4.2 创建 DAO 层接口实现类
- 在项目的 src 目录下创建一个名为 **com.spring.dao.impl** 的包，在该包下创建实现类 **AccountDaoImpl**，如下所示。

```java
package com.spring.dao.impl;
import org.springframework.jdbc.core.JdbcTemplate;
import com.spring.dao.AccountDao;
public class AccountDaoImpl implements AccountDao {
    private JdbcTemplate jdbcTemplate;
    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }
    // 汇款的实现方法
    public void out(String outUser, int money) {
        this.jdbcTemplate.update("UPDATE account SET money = money-? WHERE username = ?", money, outUser);
    }
    // 收款的实现方法
    public void in(String inUser, int money) {
        this.jdbcTemplate.update("UPDATE account SET money = money+? WHERE username = ?", money, inUser);
    }
}
```

#### 9.2.1.5 实现 Service
##### 9.2.1.5.1 创建 Service 层接口
- 在项目的 src 目录下创建一个名为 com.spring.service 的包，在该包下创建接口 AccountService，如下所示。

```java
package com.spring.service;
public interface AccountService {
    // 转账
    public void transfer(String outUser, String inUser, int money);
}
```

##### 9.2.1.5.2 创建 Service 层接口实现类
- 在项目的 src 目录下创建一个名为 **com.spring.service.impl** 的包，在该包下创建实现类 **AccountServiceImpl**，如下所示。

```java
package com.spring.service.impl;

import com.spring.dao.AccountDao;
import com.spring.service.AccountService;

public class AccountServiceImpl implements AccountService {
    private AccountDao accountDao;
    public void setAccountDao(AccountDao accountDao) {
        this.accountDao = accountDao;
    }
    public void transfer(String outUser, String inUser, int money) {
        this.accountDao.out(outUser, money);
        this.accountDao.in(inUser, money);
    }
}
```

#### 9.2.1.6 创建 Spring 配置文件
- 在项目的 src 目录下创建 Spirng 配置文件 **applicationContext.xml**，编辑后如下所示。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/tx
            http://www.springframework.org/schema/tx/spring-tx-2.5.xsd
            http://www.springframework.org/schema/aop
            http://www.springframework.org/schema/aop/spring-aop-2.5.xsd">
    <!-- 加载properties文件 -->
    <context:property-placeholder location="classpath:c3p0-db.properties" />
    <!-- 配置数据源，读取properties文件信息 -->
    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
        <property name="driverClass" value="${jdbc.driverClass}" />
        <property name="jdbcUrl" value="${jdbc.jdbcUrl}" />
        <property name="user" value="${jdbc.user}" />
        <property name="password" value="${jdbc.password}" />
    </bean>
    <!-- 配置jdbc模板 -->
    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <property name="dataSource" ref="dataSource" />
    </bean>
    <!-- 配置dao -->
    <bean id="accountDao" class="com.spring.dao.impl.AccountDaoImpl">
        <property name="jdbcTemplate" ref="jdbcTemplate" />
    </bean>
    <!-- 配置service -->
    <bean id="accountService" class="com.spring.service.impl.AccountServiceImpl">
        <property name="accountDao" ref="accountDao" />
    </bean>
    <!-- 事务管理器，依赖于数据源 -->
    <bean id="txManager"
          class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource" />
    </bean>
    <!-- 编写通知：对事务进行增强（通知），需要编写切入点和具体执行事务的细节 -->
    <tx:advice id="txAdvice" transaction-manager="txManager">
        <tx:attributes>
            <!-- 给切入点方法添加事务详情，name表示方法名称，*表示任意方法名称，propagation用于设置传播行为，read-only表示隔离级别，是否只读 -->
            <tx:method name="find*" propagation="SUPPORTS"
                       rollback-for="Exception" />
            <tx:method name="*" propagation="REQUIRED" isolation="DEFAULT"
                       read-only="false" />
        </tx:attributes>
    </tx:advice>
    <!-- aop编写，让Spring自动对目标生成代理，需要使用AspectJ的表达式 -->
    <aop:config>
        <!-- 切入点 -->
        <aop:pointcut expression="execution(* com.spring.service.*.*(..))"
                      id="txPointCut" />
        <!-- 切面：将切入点与通知整合 -->
        <aop:advisor pointcut-ref="txPointCut" advice-ref="txAdvice" />
    </aop:config>
</beans>
```

#### 9.2.1.7 创建测试类
- 在项目的 src 目录下创建 **com.spring.test** 的包，在该包下创建测试类 **AccountTest**，如下所示。

```java
package com.spring.test;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import com.spring.service.AccountService;
public class AccountTest {
    @Test
    public void test() {
        // 获得Spring容器，并操作
        String xmlPath = "applicationContext.xml";
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(
                xmlPath);
        AccountService accountService = (AccountService) applicationContext
                .getBean("accountService");
        accountService.transfer("zhangsan", "lisi", 100);
    }
}
```

#### 9.2.1.8 运行程序并查看结果

<table>
  <thead>
    <tr>
      <th>id</th>
      <th>username</th>
      <th>money</th>
    </tr>
  </thead>
    <tbody>
    <tr>
      <td>1</td>
      <td>zhangsan</td>
      <td>900</td>
    </tr>
    <tr>
      <td>2</td>
      <td>lisi</td>
      <td>1100</td>
    </tr>
  </tbody>
</table>   

- 下面通过修改案例模拟转账失败的情况，在的 transfer() 方法中添加一行代码“int i=1/0；”模拟系统断电的情况，具体代码如下所示：

```java
public void transfer(String outUser, String inUser, int money) {
    this.accountDao.out(outUser, money);
    //模拟断电
    int i = 1/0;
    this.accountDao.in(inUser, money);
}
```
- 从结果中可以看出，表中的数据并没有发生变化。由于程序在执行过程中抛出了异常，事务不能正常被提交，所以转账失败。由此可知，Spring 的事务管理生效了。

### 9.2.2 基于 Annotation 注解的事务管理
- 使用 Annotation 的方式非常简单，只需要在项目中做两件事，具体如下。

#### 9.2.2.1 注册驱动
- 修改 Spring 配置文件 **applicationContext.xml**，修改后如下所示。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/tx
            http://www.springframework.org/schema/tx/spring-tx-2.5.xsd
            http://www.springframework.org/schema/aop
            http://www.springframework.org/schema/aop/spring-aop-2.5.xsd">
    <!-- 加载properties文件 -->
    <context:property-placeholder location="classpath:c3p0-db.properties" />
    <!-- 配置数据源，读取properties文件信息 -->
    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
        <property name="driverClass" value="${jdbc.driverClass}" />
        <property name="jdbcUrl" value="${jdbc.jdbcUrl}" />
        <property name="user" value="${jdbc.user}" />
        <property name="password" value="${jdbc.password}" />
    </bean>
    <!-- 配置jdbc模板 -->
    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <property name="dataSource" ref="dataSource" />
    </bean>
    <!-- 配置dao -->
    <bean id="accountDao" class="com.spring.dao.impl.AccountDaoImpl">
        <property name="jdbcTemplate" ref="jdbcTemplate" />
    </bean>
    <!-- 配置service -->
    <bean id="accountService" class="com.spring.service.impl.AccountServiceImpl">
        <property name="accountDao" ref="accountDao" />
    </bean>
    <!-- 事务管理器，依赖于数据源 -->
    <bean id="txManager"
          class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource" />
    </bean>
    <!-- 注册事务管理驱动 -->
    <tx:annotation-driven transaction-manager="txManager"/>
</beans>
```

- 上述代码中可以看出，与原来的配置文件相比，这里只修改了事务管理器部分，新添加并注册了事务管理器的驱动。

#### 9.2.2.2 添加 @Transactional 注解
- 修改 **AccountServiceImpl**，在文件中添加** @Transactional** 注解及参数，添加后如下所示。

```java
package com.spring.service.impl;

import com.spring.dao.AccountDao;
import com.spring.service.AccountService;
import org.springframework.transaction.annotation.Isolation;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

@Transactional(propagation = Propagation.REQUIRED, isolation = Isolation.DEFAULT, readOnly = false)
public class AccountServiceImpl implements AccountService {
    private AccountDao accountDao;
    public void setAccountDao(AccountDao accountDao) {
        this.accountDao = accountDao;
    }

    public void transfer(String outUser, String inUser, int money) {
        this.accountDao.out(outUser, money);
        int i = 1/0;
        this.accountDao.in(inUser, money);
    }
}
```

#### 9.2.2.3 运行程序并查看结果
- 基于 Annotation 注解的方式同样实现了 Spring 的声明式事务管理。



